import Layout from '~/layouts/DefaultGuideLayout'

export const meta = {
  id: 'storage-schema-design',
  title: 'The Storage Schema',
  description: 'Learn about the storage schema',
  subtitle: 'Learn about the storage schema',
  sidebar_label: 'Schema',
}

Storage uses Postgres to store metadata about your buckets and objects and users can leverage the power of RLS policies for access control. It uses a dedicated schema in your project named `storage`

<Admonition type="note">
It is important to treat any records present in Storage tables as Read-Only when utilizing SQL.
All operations such as upload, copy, move, delete should **always go trough the API**.

This is important because the storage schema only stores the metadata and the actual objects are stored in a provider like S3. Deleting the metadata doesn't delete the object in the underlying storage provider. This makes your object inaccessible, but you will still be billed for it.

</Admonition>

Following is the schema that represent the Storage service

<img alt="Storage schema design" src="/docs/img/storage/schema-design.png" />

Because Storage uses Postgres we have a lot of advantages when we want to dig deeper on specific files and asset metadata.
You can query the table directly and retrieve all the information you need for specific files.

## Modifying the Schema

We strongly advice to not alter the `storage` schema and treat it as a read-only schema. This is because any updates to the schema you do might interfere with our future changes, resulting in downtime.

However, adding custom indexes is encouraged to speed up the RLS policies you write for enforcing access control.

export const Page = ({ children }) => <Layout meta={meta} children={children} />

export default Page
